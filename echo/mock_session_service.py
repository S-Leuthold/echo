# ==============================================================================
# FILE: echo/mock_session_service.py
# AUTHOR: Dr. Sam Leuthold
# PROJECT: Echo
#
# PURPOSE:
#   Provides comprehensive mock session data for testing Claude integration.
#   Creates realistic session logs for both Echo development and soil 
#   biogeochemistry research projects based on actual user work patterns.
#
# USAGE:
#   Used during development and testing to simulate the full session intelligence
#   workflow without requiring actual user sessions or live LLM calls.
# ==============================================================================

from datetime import datetime, date, time, timedelta
from typing import Dict, List, Any, Optional
import json
import uuid
from dataclasses import dataclass, field
from enum import Enum


class ProjectType(str, Enum):
    """Types of projects for categorizing session work."""
    ECHO_DEVELOPMENT = "echo_development"
    SOIL_RESEARCH = "soil_research"
    ADMINISTRATIVE = "administrative"


class SessionCategory(str, Enum):
    """Session categories matching Echo's time categorization system."""
    DEEP_WORK = "deep_work"
    MEETINGS = "meetings"
    SHALLOW_WORK = "shallow_work"
    PLANNING = "planning"
    RESEARCH = "research"
    WRITING = "writing"
    ANALYSIS = "analysis"


@dataclass
class MockSessionLog:
    """
    Structured representation of a completed work session.
    This mirrors the format that will be generated by Claude synthesis.
    """
    session_id: str
    date: date
    start_time: time
    end_time: time
    planned_duration: int  # minutes
    actual_duration: int  # minutes
    project_type: ProjectType
    project_name: str
    block_label: str
    category: SessionCategory
    
    # User input (what would be entered during session)
    goal: str
    planned_tasks: List[str]
    
    # Session outcomes
    completed_tasks: List[str]
    accomplishments_summary: str  # User's natural language summary
    outstanding_summary: str     # What's left for next time
    final_notes: str            # User's final reflections
    
    # AI-synthesized content (what Claude would generate)
    generated_log_markdown: str
    ai_insights: Dict[str, Any]  # Structured insights for future scaffolding
    
    # Session metrics
    productivity_score: int  # 1-10
    focus_rating: int       # 1-10
    energy_start: int       # 1-10
    energy_end: int         # 1-10
    
    created_at: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "session_id": self.session_id,
            "date": self.date.isoformat(),
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat(),
            "planned_duration": self.planned_duration,
            "actual_duration": self.actual_duration,
            "project_type": self.project_type.value,
            "project_name": self.project_name,
            "block_label": self.block_label,
            "category": self.category.value,
            "goal": self.goal,
            "planned_tasks": self.planned_tasks,
            "completed_tasks": self.completed_tasks,
            "accomplishments_summary": self.accomplishments_summary,
            "outstanding_summary": self.outstanding_summary,
            "final_notes": self.final_notes,
            "generated_log_markdown": self.generated_log_markdown,
            "ai_insights": self.ai_insights,
            "productivity_score": self.productivity_score,
            "focus_rating": self.focus_rating,
            "energy_start": self.energy_start,
            "energy_end": self.energy_end,
            "created_at": self.created_at.isoformat()
        }


class MockSessionService:
    """
    Service for generating and managing mock session data for testing.
    Creates realistic session logs based on actual user work patterns.
    """
    
    def __init__(self):
        self.sessions: List[MockSessionLog] = []
        self._generate_echo_sessions()
        self._generate_research_sessions()
    
    def _generate_echo_sessions(self) -> None:
        """Generate realistic Echo development sessions."""
        
        # Recent frontend work (last week)
        echo_sessions = [
            {
                "date": date(2025, 7, 18),
                "start_time": time(9, 0),
                "end_time": time(10, 30),
                "project_name": "Echo",
                "block_label": "Echo | Session Management UI",
                "category": SessionCategory.DEEP_WORK,
                "goal": "Implement the session state management system with four distinct states",
                "planned_tasks": [
                    "Create session state enum and transitions",
                    "Implement TranquilState component",
                    "Build SpinUpState with AI insights",
                    "Add keyboard navigation between states"
                ],
                "completed_tasks": [
                    "Created comprehensive session state enum with TRANQUIL, SPIN_UP, ACTIVE, SPIN_DOWN",
                    "Implemented TranquilState with contextual quotes and re-entry controls",
                    "Built SpinUpState with Echo Insights and task scaffolding",
                    "Added theater mode toggle functionality"
                ],
                "accomplishments_summary": "Successfully architected and implemented the core session state management system. The four-state workflow is now functional with smooth transitions and contextual UI elements. Theater mode provides an immersive experience during personal time blocks.",
                "outstanding_summary": "Still need to implement the ActiveSessionState premium dashboard and SpinDownState debrief interface. The session log modal also needs Novel.sh integration for rich text editing.",
                "final_notes": "The session state pattern is working beautifully. The theater mode concept adds a nice touch to the tranquil state. Next session should focus on the active session cockpit design.",
                "productivity_score": 9,
                "focus_rating": 8,
                "energy_start": 7,
                "energy_end": 8
            },
            {
                "date": date(2025, 7, 19),
                "start_time": time(8, 45),
                "end_time": time(10, 15),
                "project_name": "Echo",
                "block_label": "Echo | Timeline & Calendar",
                "category": SessionCategory.DEEP_WORK,
                "goal": "Fix timeline positioning issues and implement proper time markers",
                "planned_tasks": [
                    "Debug timeline mathematical positioning",
                    "Add hourly time markers (5 AM - 11 PM)",
                    "Fix sticky calendar positioning",
                    "Optimize timeline scaling for viewport"
                ],
                "completed_tasks": [
                    "Resolved timeline positioning with proper pixel-per-minute scaling",
                    "Implemented hour-boundary time marker generation",
                    "Fixed calendar sticky positioning using CSS Grid approach",
                    "Added dynamic timeline scaling based on viewport height"
                ],
                "accomplishments_summary": "Solved all the major timeline positioning issues that were causing visual inconsistencies. The timeline now displays proper hourly markers from 5 AM to 11 PM and scales perfectly to fit the viewport without scrolling. The sticky calendar positioning issue is completely resolved.",
                "outstanding_summary": "Timeline is solid now, but we should add buffer time visualization and improve the collision detection for overlapping blocks. Also want to add drag-and-drop functionality for schedule adjustments.",
                "final_notes": "This was a breakthrough session. The mathematical approach to timeline positioning finally clicked. The key insight was treating each minute as exactly 2 pixels and building everything from that foundation.",
                "productivity_score": 10,
                "focus_rating": 9,
                "energy_start": 8,
                "energy_end": 9
            },
            {
                "date": date(2025, 7, 20),
                "start_time": time(14, 0),
                "end_time": time(15, 30),
                "project_name": "Echo",
                "block_label": "Echo | Novel.sh Integration",
                "category": SessionCategory.DEEP_WORK,
                "goal": "Integrate Novel.sh WYSIWYG editor for session log editing",
                "planned_tasks": [
                    "Install Novel.sh dependency",
                    "Create NovelMarkdownEditor wrapper component",
                    "Update SessionLogModal to use Novel editor",
                    "Configure extensions and styling"
                ],
                "completed_tasks": [
                    "Successfully installed @novel-js/core and configured dependencies",
                    "Built comprehensive NovelMarkdownEditor component with extensions",
                    "Integrated editor into SessionLogModal with proper sizing",
                    "Fixed bullet list input rules and markdown parsing"
                ],
                "accomplishments_summary": "Novel.sh integration is complete and working beautifully. The session log modal now provides a rich editing experience with proper markdown support, bullet lists, and formatting options. The editor feels premium and matches our design system.",
                "outstanding_summary": "The integration is solid, but we could explore additional Novel extensions for enhanced functionality. Also want to add autosave functionality and better error handling for edge cases.",
                "final_notes": "Novel.sh was exactly what we needed for rich text editing. The API is clean and the integration was smoother than expected. This will significantly improve the session log creation experience.",
                "productivity_score": 8,
                "focus_rating": 9,
                "energy_start": 6,
                "energy_end": 7
            },
            {
                "date": date(2025, 7, 21),
                "start_time": time(10, 0),
                "end_time": time(11, 30),
                "project_name": "Echo",
                "block_label": "Echo | Backend API Architecture",
                "category": SessionCategory.PLANNING,
                "goal": "Design the backend architecture for Claude session intelligence integration",
                "planned_tasks": [
                    "Map out three-phase LLM integration points",
                    "Design database schema for session scaffolds",
                    "Plan API endpoints for session management",
                    "Document error handling strategies"
                ],
                "completed_tasks": [
                    "Defined three clear integration points: post-planning scaffolding, session start checklist, session log synthesis",
                    "Designed session_scaffolds and session_logs database tables",
                    "Planned RESTful API structure with proper error handling",
                    "Created comprehensive documentation for Claude integration workflow"
                ],
                "accomplishments_summary": "Solid architectural planning session. We now have a clear roadmap for the Claude integration with well-defined data flows and API contracts. The three-phase approach will ensure smooth user experience while maintaining system reliability.",
                "outstanding_summary": "Architecture is planned, now need to implement the actual backend services and API endpoints. Also need to create comprehensive mock data for testing the full workflow.",
                "final_notes": "This planning session was crucial for getting the Claude integration right. The hybrid approach of pre-computed scaffolds plus real-time generation should give us the best of both worlds: speed and intelligence.",
                "productivity_score": 7,
                "focus_rating": 8,
                "energy_start": 7,
                "energy_end": 7
            }
        ]
        
        # Convert to MockSessionLog objects
        for session_data in echo_sessions:
            session = self._create_session_log(
                project_type=ProjectType.ECHO_DEVELOPMENT,
                **session_data
            )
            self.sessions.append(session)
    
    def _generate_research_sessions(self) -> None:
        """Generate realistic soil biogeochemistry research sessions."""
        
        research_sessions = [
            {
                "date": date(2025, 7, 17),
                "start_time": time(9, 30),
                "end_time": time(11, 0),
                "project_name": "Soil Carbon Dynamics",
                "block_label": "Research | Data Analysis",
                "category": SessionCategory.ANALYSIS,
                "goal": "Analyze soil carbon sequestration data from the prairie restoration sites",
                "planned_tasks": [
                    "Process raw spectroscopy data from June field sampling",
                    "Run statistical analysis on carbon content by depth",
                    "Compare pre/post restoration carbon accumulation rates",
                    "Generate preliminary figures for manuscript"
                ],
                "completed_tasks": [
                    "Successfully processed 240 soil samples from spectroscopy analysis",
                    "Completed ANOVA analysis showing significant carbon increases at 0-15cm depth",
                    "Generated time-series comparison charts for 5-year restoration period",
                    "Created preliminary figure showing 23% increase in soil organic carbon"
                ],
                "accomplishments_summary": "Excellent progress on the prairie restoration carbon analysis. The data clearly shows significant soil carbon accumulation in the top soil layers after 5 years of restoration. The statistical analysis confirms our hypothesis about rapid carbon sequestration in restored prairie systems.",
                "outstanding_summary": "Need to extend analysis to deeper soil layers (15-30cm, 30-45cm) to get full carbon profile. Also want to correlate carbon increases with specific plant community establishment data. Should prepare figures for the upcoming conference presentation.",
                "final_notes": "This dataset is really compelling. The 23% increase in soil organic carbon is substantial and should make for a strong manuscript. The restoration timeline data will be valuable for land management recommendations.",
                "productivity_score": 9,
                "focus_rating": 9,
                "energy_start": 8,
                "energy_end": 8
            },
            {
                "date": date(2025, 7, 18),
                "start_time": time(14, 30),
                "end_time": time(16, 0),
                "project_name": "Microbial Ecology Study",
                "block_label": "Research | Lab Work",
                "category": SessionCategory.DEEP_WORK,
                "goal": "Process soil samples for microbial community DNA extraction",
                "planned_tasks": [
                    "Extract DNA from 48 soil samples using PowerSoil Pro kit",
                    "Quantify DNA concentrations using NanoDrop",
                    "Prepare samples for 16S rRNA gene sequencing",
                    "Update lab notebook with extraction yields"
                ],
                "completed_tasks": [
                    "Successfully extracted DNA from all 48 samples with good yield",
                    "Quantified concentrations - average yield 45.2 ng/μL (excellent quality)",
                    "Prepared sequencing library with proper barcoding",
                    "Updated digital lab notebook with complete extraction protocols"
                ],
                "accomplishments_summary": "Highly productive lab session with excellent DNA extraction results. All samples yielded high-quality DNA suitable for sequencing analysis. The PowerSoil Pro kit continues to give consistent results for our soil types.",
                "outstanding_summary": "Samples are ready for sequencing submission. Need to finalize the sequencing metadata sheet and submit to the core facility. Should also prepare the bioinformatics pipeline for when data returns.",
                "final_notes": "Lab work went smoothly today. The new extraction protocol modifications are working well - getting much better yields than with the old method. Should standardize this approach for future extractions.",
                "productivity_score": 8,
                "focus_rating": 8,
                "energy_start": 7,
                "energy_end": 7
            },
            {
                "date": date(2025, 7, 19),
                "start_time": time(10, 30),
                "end_time": time(12, 0),
                "project_name": "Climate Change Impact Study",
                "block_label": "Research | Manuscript Writing",
                "category": SessionCategory.WRITING,
                "goal": "Draft the methods section for the climate warming experiment paper",
                "planned_tasks": [
                    "Write detailed field site description",
                    "Document experimental design and warming treatment setup",
                    "Describe soil sampling and analytical methods",
                    "Review and revise for clarity and completeness"
                ],
                "completed_tasks": [
                    "Completed comprehensive field site characterization (650 words)",
                    "Documented warming chamber design and temperature monitoring protocols",
                    "Detailed all soil chemistry analytical procedures with proper citations",
                    "Revised entire methods section for consistency and clarity"
                ],
                "accomplishments_summary": "Strong writing session that produced a complete, well-structured methods section. The experimental design is clearly described and all analytical procedures are properly documented with appropriate citations. The writing flows well and should be easy for reviewers to follow.",
                "outstanding_summary": "Methods section is solid, now need to work on the results section. Should start with the temperature data analysis and soil chemistry changes. Also need to create the site map figure and experimental design diagram.",
                "final_notes": "Writing felt productive today. The methods section was challenging because of the complexity of the experimental design, but I think we captured all the important details. Good foundation for the rest of the manuscript.",
                "productivity_score": 8,
                "focus_rating": 9,
                "energy_start": 7,
                "energy_end": 6
            },
            {
                "date": date(2025, 7, 22),
                "start_time": time(9, 0),
                "end_time": time(10, 30),
                "project_name": "Grant Proposal - NSF",
                "block_label": "Research | Grant Writing",
                "category": SessionCategory.WRITING,
                "goal": "Work on the project description for the NSF LTREB proposal",
                "planned_tasks": [
                    "Outline the 20-year research timeline",
                    "Draft the intellectual merit section",
                    "Describe the broader impacts of long-term soil monitoring",
                    "Review NSF guidelines for compliance"
                ],
                "completed_tasks": [
                    "Created detailed 20-year research timeline with key milestones",
                    "Drafted strong intellectual merit section highlighting novel aspects",
                    "Developed comprehensive broader impacts plan including education components",
                    "Reviewed proposal against NSF criteria and made formatting adjustments"
                ],
                "accomplishments_summary": "Productive grant writing session that advanced the NSF LTREB proposal significantly. The 20-year timeline is realistic and compelling, and the intellectual merit case is strong. The broader impacts section includes meaningful education and outreach components.",
                "outstanding_summary": "Project description is taking shape well. Still need to work on the detailed budget and budget justification. Also need to finalize the data management plan and complete the facilities description.",
                "final_notes": "Grant writing is always challenging, but this proposal feels strong. The long-term nature of the LTREB program is perfect for our soil carbon research questions. Deadline is approaching but we're in good shape.",
                "productivity_score": 7,
                "focus_rating": 8,
                "energy_start": 8,
                "energy_end": 7
            }
        ]
        
        # Convert to MockSessionLog objects  
        for session_data in research_sessions:
            session = self._create_session_log(
                project_type=ProjectType.SOIL_RESEARCH,
                **session_data
            )
            self.sessions.append(session)
    
    def _create_session_log(self, project_type: ProjectType, **kwargs) -> MockSessionLog:
        """Create a MockSessionLog with AI-generated content."""
        
        # Generate session ID
        session_id = f"{kwargs['date'].isoformat()}-{kwargs['start_time'].strftime('%H%M')}-{kwargs['project_name'].lower().replace(' ', '-')}"
        
        # Calculate durations
        start_dt = datetime.combine(kwargs['date'], kwargs['start_time'])
        end_dt = datetime.combine(kwargs['date'], kwargs['end_time'])
        actual_duration = int((end_dt - start_dt).total_seconds() / 60)
        planned_duration = actual_duration  # Assuming on-time completion for now
        
        # Generate AI-synthesized log markdown (following the hybrid voice spec)
        markdown_log = self._generate_session_log_markdown(kwargs)
        
        # Generate AI insights for future scaffolding
        ai_insights = self._generate_ai_insights(kwargs, project_type)
        
        return MockSessionLog(
            session_id=session_id,
            date=kwargs['date'],
            start_time=kwargs['start_time'],
            end_time=kwargs['end_time'],
            planned_duration=planned_duration,
            actual_duration=actual_duration,
            project_type=project_type,
            project_name=kwargs['project_name'],
            block_label=kwargs['block_label'],
            category=kwargs['category'],
            goal=kwargs['goal'],
            planned_tasks=kwargs['planned_tasks'],
            completed_tasks=kwargs['completed_tasks'],
            accomplishments_summary=kwargs['accomplishments_summary'],
            outstanding_summary=kwargs['outstanding_summary'],
            final_notes=kwargs['final_notes'],
            generated_log_markdown=markdown_log,
            ai_insights=ai_insights,
            productivity_score=kwargs['productivity_score'],
            focus_rating=kwargs['focus_rating'],
            energy_start=kwargs['energy_start'],
            energy_end=kwargs['energy_end']
        )
    
    def _generate_session_log_markdown(self, session_data: Dict) -> str:
        """Generate AI-synthesized session log following the hybrid voice specification."""
        
        # Format the markdown according to the specification
        category_formatted = session_data['category'].value.replace('_', ' ').title()
        duration_str = f"{int((datetime.combine(session_data['date'], session_data['end_time']) - datetime.combine(session_data['date'], session_data['start_time'])).total_seconds() / 60)} minutes"
        
        markdown = f"""# Session: {session_data['block_label']}

**Project:** {session_data['project_name']}  
**Date:** {session_data['date'].isoformat()} • **Duration:** {duration_str} • **Category:** {category_formatted}

### [AI] Executive Summary

This was a highly productive session focused on {session_data['goal'].lower()}. The primary objectives were successfully achieved with strong execution across all planned tasks. The session demonstrated effective time management and maintained high focus throughout the work period.

### Accomplishments

You successfully completed the following:
{chr(10).join(f'- {task}' for task in session_data['completed_tasks'])}

### Outstanding & Next Steps

Here is what you have remaining for next time:

* **Immediate Follow-up:**
{chr(10).join(f'    * [ ] {item}' for item in self._extract_immediate_items(session_data['outstanding_summary']))}

* **Rollover Tasks for Next Session:**
{chr(10).join(f'    * {item}' for item in self._extract_rollover_items(session_data['outstanding_summary']))}

### [AI] Performance Analysis & Insights

* **Key Insight:** {self._generate_key_insight(session_data)}
* **Pattern Detected:** I've noticed this is consistent with your high-productivity pattern in {session_data['category'].value.replace('_', ' ')} sessions. My analysis shows you maintain strong focus during {session_data['start_time'].strftime('%I:%M %p')} time blocks.
* **Recommendation:** Based on this session's success, I recommend scheduling similar {session_data['category'].value.replace('_', ' ')} work during this time slot for optimal productivity.
"""
        
        return markdown
    
    def _extract_immediate_items(self, outstanding_summary: str) -> List[str]:
        """Extract actionable immediate items from outstanding summary."""
        # Simple heuristic - look for sentences mentioning "need to" or "should"
        sentences = outstanding_summary.split('. ')
        immediate_items = []
        for sentence in sentences[:2]:  # Take first 2 actionable items
            if any(keyword in sentence.lower() for keyword in ['need to', 'should', 'want to']):
                # Clean up the sentence to make it actionable
                item = sentence.strip()
                if item.startswith('Still '):
                    item = item[6:]  # Remove "Still "
                if item.startswith('Also '):
                    item = item[5:]  # Remove "Also "
                immediate_items.append(item.capitalize())
        return immediate_items[:2]  # Limit to 2 items

    def _extract_rollover_items(self, outstanding_summary: str) -> List[str]:
        """Extract rollover tasks from outstanding summary."""
        # Look for future work items
        sentences = outstanding_summary.split('. ')
        rollover_items = []
        for sentence in sentences[2:]:  # Skip immediate items
            if len(sentence.strip()) > 0:
                item = sentence.strip()
                if not item.endswith('.'):
                    item += '.'
                rollover_items.append(item)
        return rollover_items[:2]  # Limit to 2 items
    
    def _generate_key_insight(self, session_data: Dict) -> str:
        """Generate a contextual key insight based on session data."""
        insights = [
            f"The structured approach to {session_data['category'].value.replace('_', ' ')} work is yielding consistently strong results.",
            f"Breaking down complex {session_data['project_name']} tasks into specific deliverables improves execution quality.",
            f"The {session_data['start_time'].strftime('%I:%M %p')} time slot appears to be optimal for {session_data['category'].value.replace('_', ' ')} sessions.",
            f"Maintaining clear session goals significantly improves task completion rates in {session_data['project_name']} work."
        ]
        # Return a contextually appropriate insight using project name as hash source
        return insights[hash(session_data['project_name'] + str(session_data['date'])) % len(insights)]
    
    def _generate_ai_insights(self, session_data: Dict, project_type: ProjectType) -> Dict[str, Any]:
        """Generate structured AI insights for future scaffolding."""
        return {
            "session_quality": "high" if session_data['productivity_score'] >= 8 else "medium",
            "optimal_time_slot": session_data['start_time'].strftime('%H:%M'),
            "preferred_duration": int((datetime.combine(session_data['date'], session_data['end_time']) - 
                                    datetime.combine(session_data['date'], session_data['start_time'])).total_seconds() / 60),
            "category_performance": session_data['category'].value,
            "key_success_factors": [
                "Clear session goals",
                "Structured task breakdown", 
                "Consistent time management"
            ],
            "recommended_followup": self._extract_immediate_items(session_data['outstanding_summary'])[:1],
            "project_momentum": "strong" if session_data['focus_rating'] >= 8 else "moderate",
            "energy_pattern": {
                "start": session_data['energy_start'],
                "end": session_data['energy_end'],
                "trend": "increasing" if session_data['energy_end'] > session_data['energy_start'] else "stable"
            }
        }
    
    def get_sessions_by_project(self, project_name: str, limit: int = 3) -> List[MockSessionLog]:
        """Get recent sessions for a specific project."""
        project_sessions = [s for s in self.sessions if s.project_name == project_name]
        return sorted(project_sessions, key=lambda x: x.date, reverse=True)[:limit]
    
    def get_all_sessions(self) -> List[MockSessionLog]:
        """Get all mock sessions sorted by date."""
        return sorted(self.sessions, key=lambda x: x.date, reverse=True)
    
    def export_sessions_json(self, filepath: str) -> None:
        """Export all sessions to JSON file."""
        sessions_data = [session.to_dict() for session in self.sessions]
        with open(filepath, 'w') as f:
            json.dump(sessions_data, f, indent=2, default=str)